@[TOC](目录)
# 1.实习题目
【问题描述】
    设计并实现AVL树类。
【基本要求】
   （1）定义AVL树类；
   （2）设计并实现AVL树的搜索、插入和删除算法；
   （3）可以用int型作为模板数据类型，验证算法的正确性。
# 2.程序设计
本程序利用模板类来编写，共两个文件：一个是主函数.cpp文件，另一个是对高度平衡二叉搜索树（AVL树）的各个操作函数的声明和定义的.h文件。
首先说明主函数.cpp文件：呃呃，，不想每次运行都输入数据，所以提前在代码前面把数据都定义并放在数组里面了，有需要再改吧。接下来定义一个AVL树指针tree，并对模板类初始化为int型，用来调用AVL树类里面的函数。利用for(i=0;i<(sizeof(array))/(sizeof(array[0]));i++)循环并调用插入函数Insert依次插入数组内的元素，为了检查建立的高度平衡二叉搜索树的正确性，输出该树的信息，如前中后序遍历以及方便观察树的结构凹入法输入树结构。然后通过输出树的信息（输出内容同上面一样）来验证删除Remove、查找Search结点函数是否正确，执行完这些之后最后调用Release函数释放AVL树所占用的空间，程序结束。
然后是函数声明和定义的.h文件：首先是AVL树结点的结构体定义，里面包含节点关键字、高度、左孩子、右孩子以及以及一个构造函数。然后是AVL树类：先是在类public里面声明构造函数以及析构函数，然后就是树高度、插入、删除等函数，然后在private里再声明它们的同名函数，但参数不一样，在主函数是通过在public里面同名函数调用private的同名函数的，隐藏树的根，保护了AVL树的数据。接下来是构造函数和析构函数的定义，在析构函数里面放Release函数来释放AVL树占用的空间。
求树的高度函数是若树tree不为空，则返回tree->Height,并利用public里面的同名函数进行调用（后面都是这样，所以只解释private里面函数定义了），然后就是一个比较大小并输出大的一方的函数，还有利用递归编写的前中后序遍历函数。接下来就是查找结点函数Search，若结点空或则搜索到结点，则返回改结点指针，否则若x < x->key则遍历搜左子树，否则遍历搜索右子树。查找最小结点的函数若树不空则往左子树查找即可，而查找最大结点正好相反。
然后就是为了调整树平衡的左单(RR型)、右单旋转(LL型)：以右单旋转为例，即以LL型的中间结点为旋转点，将不平衡的结点右旋下来即可平衡，然后就是调整结点高度，如上图所示。而对于LR型的不平衡结点进行左右双旋转，首先对中间结点调用左单旋函数先调整，再调用右单旋转函数进行调整，RL型则相反，如右图所示
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308215914149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzk0NjMz,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/202103082159462.png#pic_center)

接下来是将值为key的结点插入到AVL树中的函数Insert，首先判断若数空则建立新结点，否则if(key < tree->key)插入左子树，if(key > tree->key)插入到右子树，递归调用Insert直到找到插入点并插入，也即是到了叶结点，判断插入后的左右子树的的、高度差是否为2，也即不平衡，不平衡则对于插入到左子树的情况，若if(key < tree->left
->key)则进行右单旋，否则进行左右单旋；对于插入到右子树的情况若失衡则进行左单旋或者右左单旋。调整结束之后再对插入的结点赋予高度即可。
后面就是删除结点函数Remove：若树为空则返回nullptr，否则if(key1->key < tree->key)待删除的节点在左子树中，递归调用Remove函数，找到删除的节点。若删除的结点左右孩子结点不空，如果它的左子树比右子树高，则找到删除的结点的左子树后面的最大结点来代替删除的结点的位置，如果它的右子树比左子树高，则找到删除的结点的右子树后面的最小结点来代替删除的结点的位置；除了左右孩子都非空的其他情况，则用非空的那个来代替删除的结点。同样的删除后的树失衡则利用左单旋、右单旋、左右双旋转以及右左双旋转调整树（递归算法说得可能不是很清楚，看代码应该就可以理解）。
然后是一个之前实习写过的凹入法输出二叉树（AVL树本质上也是二叉树），最后是释放AVL树的函数，若为空，则什么都不返回，否则若左右子树不空则递归释放，最后是delete tree即可。
# 3.测试结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210308215407734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzk0NjMz,size_16,color_FFFFFF,t_70#pic_center)
